---
title: "Rapport de qualité"
subtitle: "Du `r params$rapport_debut` au `r params$rapport_fin`"
format: html
toc: true
toc-depth: 3
embed-resources: true
params:
  dir_proj: ""
  fichier_menage: ""
  rapport_debut: ""
  rapport_fin: ""
execute: 
  echo: false
  error: false
  warning: false
---

```{r}
#| label: définir répertoires

source(fs::path(params$dir_proj, "R", "02_definir_repertoires.R"))
```

```{r}
#| label: charges les programmes pertinents

dirs$suivre$r |>
	fs::dir_ls() |>
	purrr::walk(.f = ~ source(.x))
```

```{r}
#| label: identifier les entretiens achevés

entretiens_acheves <- dirs$obtenir$menage$fusionnees |>
  fs::path(paste0(params$fichier_menage, ".dta")) |>
  # ingérer la base principale
	haven::read_dta() |>
  # trier les entretiens
  # par les données de l'entretien
  dplyr::filter(
    # résultat de l'entretien: rempli, ménage sélectionné ou de replacement
    (s00q08 %in% c(1, 2))
    &
    # toutes les visites ont été faites
    (visite1 == 1 & visite2 == 2 & visite3 == 3)
  ) |>
  dplyr::mutate(interview_complete = 1) |>
  dplyr::select(interview__id, interview__key)

```

```{r}
#| label: charger les bases filtrées
 
# composer les spécifications pour les fichiers à charger
bases_specs <- c(
  # vecteur des fichiers
  params$fichier_menage,
  "interview__actions"
) |>
  # transformer en base
	tibble::enframe(name = NULL, value = "base") |>
  # ajouter / créer des colonnes pour la fonction
	dplyr::mutate(
    nom = dplyr::case_when(
      base == params$fichier_menage ~ "menages",
      .default = sub(x = base, pattern = "__", replacement = "_")
    ),
    dir = dirs$obtenir$menage$fusionnees,
    entretiens_acheves = list(entretiens_acheves)
  ) |>
  # organiser en ordre des arguments de la fonction
	dplyr::select(dir, base, nom, entretiens_acheves)

# capter les bases filtrées dans une liste de bases
dfs_filtrees <- bases_specs |>
	purrr::pmap(.f = filtrer_base) |>
	rlang::set_names(nm = bases_specs$nom)

```

```{r}
#| label: charger la composition des équipes

superviseur_enqueteur <- fs::path(dirs$obtenir$meta, "team_composition.dta") |>
  # ingérer la base
	haven::read_dta() |>
  # enlever d'éventuels utilisateur archivés
  dplyr::filter(IsArchived == 0) |>
  # retenir les colonnes superviseur et enquêteur, changeant les nom
  # dans pour être en phase avec ceux de la base de entretiens et l'enquêteur
  # responsable
	dplyr::select(
    supervisor = SupervisorName,
    interviewer = UserName
  )

```

```{r}
#| label: identifier l'enquêteur responsable pour chaque entretien

enquetes_enqueteur_responsable <- dfs_filtrees$interview_actions |>
	dplyr::group_by(interview__id, interview__key) |>
  # select the last completion event
  # complete
	dplyr::filter(action == 3) |>
	# last
	dplyr::filter(dplyr::row_number() == dplyr::n()) |>
  dplyr::ungroup() |>
	dplyr::mutate(
    # date d'achèvement
    date_entretien = lubridate::as_date(date),
    # semaine d'achèvement
    semaine_entretien = lubridate::floor_date(
      x = date_entretien, 
      unit = "week", 
      # week starts on Monday
      week_start = getOption("lubridate.week.start", 1)
    ),
    # dans la période du rapport
    periode_rapport = lubridate::`%within%`(
      date_entretien,
      lubridate::interval(
          start = params$rapport_debut, 
          end = params$rapport_fin
      )
    )
  ) |>
	dplyr::select(
    interview__id, interview__key,
    interviewer = originator,
    supervisor = responsible__name,
    date_entretien, semaine_entretien, periode_rapport
  )

```

```{r}
#| label: créer une base qui attribue chaque entretien à un enquêteur et supervisur
 
equipe_enqueteur_entretien <- superviseur_enqueteur |>
	dplyr::left_join(
    y = enquetes_enqueteur_responsable,
    by = c("supervisor", "interviewer")
  ) |>
	dplyr::select(
    supervisor, interviewer, interview__id, interview__key,
    date_entretien, semaine_entretien, periode_rapport
  )

```

```{r}
#| label: créer un sytle pour les tableaux reactable

# {reactable} table style
reactable_style <- reactable::reactableTheme(
  headerStyle = list(color = "#ffffff", background = "#0F2B1D"),
  groupHeaderStyle = list(color = "#ffffff", background = "#0F2B1D"),
  stripedColor = "#edfaea",
  searchInputStyle = list(
    backgroundColor = "#edfaea",
    borderColor = "#8cc0a5",
    borderWidth = "medium",
    "&:focus" = list(backgroundColor = "#edfaea", borderWidth = "thick", borderColor = "#0F2B1D"),
    "&:hover, &:focus" = list(borderWidth = "thick", borderColor = "#8cc0a5"),
    "&:hover::placeholder, &:focus::placeholder" = list(color = "#8cc0a5")            
  )
)

# reactable UI text
reactable_fr <- reactable::reactableLang(
  searchPlaceholder = "Rechercher",
  searchLabel = "Rechercher",
  noData = "Aucune ligne retrouvée",
  pageNext = "Suivant",
  pagePrevious = "Précédent",
  pageNumbers = "{page} de {pages}",
  pageInfo = "Lignes {rowStart} à {rowEnd} de {rows} lignes"
)

```

## Taille du ménage

```{r}
#| label: taille du ménage

# ------------------------------------------------------------------------------
# calculer les statistiques
# ------------------------------------------------------------------------------

taille_menage_par_entretien <- equipe_enqueteur_entretien |>
	dplyr::left_join(dfs_filtrees$menages, by = c("interview__id", "interview__key")) |>
	dplyr::mutate(
    dplyr::across(
      .cols = dplyr::matches("NOM_PRENOMS__[0-9]+$"),
      .fns = ~ !.x %in% c("##N/A##", "", NA_character_)
    ),
    n_membres = rowSums(
      dplyr::pick(dplyr::matches("NOM_PRENOMS__[0-9]$")),
      na.rm = TRUE
    )
  ) |>
	dplyr::select(
    supervisor, interviewer,
    interview__id, interview__key,
    n_membres,
    semaine_entretien, periode_rapport
  )

taille_menage_par_equipe <- taille_menage_par_entretien |>
	dplyr::filter(periode_rapport == TRUE) |>
	dplyr::group_by(supervisor) |>
	dplyr::summarise(
    n_menages = dplyr::n(),
    minimum = fivenum(n_membres, na.rm = TRUE)[1], 
    lower_hinge = fivenum(n_membres, na.rm = TRUE)[2], 
    median = fivenum(n_membres, na.rm = TRUE)[3], 
    upper_hinge = fivenum(n_membres, na.rm = TRUE)[4], 
    maximum = fivenum(n_membres, na.rm = TRUE)[5]
  ) |>
	dplyr::ungroup()

taille_menage_ensemble <- taille_menage_par_entretien |>
	dplyr::filter(periode_rapport == TRUE) |>
	dplyr::summarise(
    n_menages = dplyr::n(),
    minimum = fivenum(n_membres, na.rm = TRUE)[1], 
    lower_hinge = fivenum(n_membres, na.rm = TRUE)[2], 
    median = fivenum(n_membres, na.rm = TRUE)[3], 
    upper_hinge = fivenum(n_membres, na.rm = TRUE)[4], 
    maximum = fivenum(n_membres, na.rm = TRUE)[5]
  ) |>
	dplyr::mutate(supervisor = "Ensemble", .before = 1)

taille_menage_tendance_par_equipe <- taille_menage_par_entretien |>
  # calculer la médiane par superviseur et par semaine
  dplyr::group_by(supervisor, semaine_entretien) |>
  dplyr::summarise(n_membres = median(n_membres, na.rm = TRUE)) |>
  dplyr::ungroup() |>
  # ordonner la base par superviseur et par semaine
  dplyr::arrange(supervisor, semaine_entretien) |>
  # créer une liste de mesures ordonnées par date pour chaque superviseur
  # d'abord, en ramenant les colonnes de la mesure et de la date en df imbrique
  # de sorte à préserver l'ordre
  # ensuite, en extrayant la mesure pour en faire une colonne liste
  dplyr::group_by(supervisor) |>
  tidyr::nest(tendances_df = c(semaine_entretien, n_membres)) |>
  dplyr::mutate(tendance = purrr::map(tendances_df, ~ .x$n_membres)) |>
  dplyr::ungroup() |>
  dplyr::select(supervisor, tendance)


taille_menage_tendance_ensemble <- taille_menage_par_entretien |>
  # calculer la médiane par semaine
  dplyr::group_by(semaine_entretien) |>
  dplyr::summarise(n_membres = median(n_membres, na.rm = TRUE)) |>
  dplyr::ungroup() |>
  # ordonner la base par superviseur et par semaine
  dplyr::arrange(semaine_entretien) |>
  # créer une liste de mesures ordonnées par date
  # d'abord, en ramenant les colonnes de la mesure et de la date en df imbrique
  # de sorte à préserver l'ordre
  # ensuite, en extrayant la mesure pour en faire une colonne liste
  tidyr::nest(tendances_df = c(semaine_entretien, n_membres)) |>
  dplyr::mutate(tendance = purrr::map(tendances_df, ~ .x$n_membres)) |>
  dplyr::ungroup() |>
  dplyr::select(tendance) |>
  dplyr::mutate(supervisor = "Ensemble", .before = 1)

# ------------------------------------------------------------------------------
# composer la base de statistiques
# ------------------------------------------------------------------------------

taille_menage_stats <- dplyr::bind_rows(
  taille_menage_ensemble, taille_menage_par_equipe
)

taille_menage_tendance <- dplyr::bind_rows(
  taille_menage_tendance_par_equipe, taille_menage_tendance_ensemble
)

taille_menage_tbl <- taille_menage_stats |>
	dplyr::left_join(taille_menage_tendance, by = "supervisor")

# ------------------------------------------------------------------------------
# composer le tableau
# ------------------------------------------------------------------------------

reactable::reactable(
  data = taille_menage_tbl,
  defaultColDef = reactable::colDef(
    width = 50
  ),
  columns = list(
    supervisor = reactable::colDef(
        name = "Équipe",
        width = 120
    ),
    n_menages = reactable::colDef(
        name = "N. obs",
        width = 100
    ),
    minimum = reactable::colDef(name = "Min"),
    lower_hinge = reactable::colDef(name = "Q1"),
    median = reactable::colDef("Méd"),
    upper_hinge = reactable::colDef("Q3"),
    maximum = reactable::colDef("Max"),
    tendance = reactable::colDef(
      name = "Tendance",
      width = 400,
      cell = function(value, index) {
        dataui::dui_sparkline(
          data = value,
          components = list(
            dataui::dui_sparklineseries(
              # styling
              stroke = "#7E9384",
              showArea = TRUE,
              fill = "#7E9384"
            ),
            dataui::dui_tooltip(
              dataui::dui_sparkpointseries(
                #styling
                stroke = "#7E9384",
                fill = "#fff",
                #litle extra interactivity for demostration purposes
                renderLabel = htmlwidgets::JS("(d) => d.toFixed(2)")
              )
            )
          )
        )
      }
    )
  ),
  columnGroups = list(
    reactable::colGroup(
      name = "Période du rapport",
      columns = c(
        "n_menages", 
        "minimum", "lower_hinge", "median", "upper_hinge", "maximum"
      )
    ),
    reactable::colGroup(
      name = "Période de l'enquête",
      columns = "tendance"
    )
  ),
  striped = TRUE,
  sortable = TRUE,
  searchable = TRUE,
  fullWidth = FALSE,
  compact = TRUE,
  theme = reactable_style,
  language = reactable_fr  
)

```