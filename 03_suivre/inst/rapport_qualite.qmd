---
title: "Rapport de qualité"
subtitle: "Du `r params$rapport_debut` au `r params$rapport_fin`"
format: html
toc: true
toc-depth: 3
embed-resources: true
params:
  dir_proj: ""
  fichier_menage: ""
  rapport_debut: ""
  rapport_fin: ""
execute: 
  echo: false
  error: false
  warning: false
---

```{r}
#| label: définir répertoires

source(fs::path(params$dir_proj, "R", "02_definir_repertoires.R"))
```

```{r}
#| label: charges les programmes pertinents

dirs$suivre$r |>
	fs::dir_ls() |>
	purrr::walk(.f = ~ source(.x))
```

```{r}
#| label: identifier les entretiens achevés

entretiens_acheves <- dirs$obtenir$menage$fusionnees |>
  fs::path(paste0(params$fichier_menage, ".dta")) |>
  # ingérer la base principale
	haven::read_dta() |>
  # trier les entretiens
  # par les données de l'entretien
  dplyr::filter(
    # résultat de l'entretien: rempli, ménage sélectionné ou de replacement
    (s00q08 %in% c(1, 2))
    &
    # toutes les visites ont été faites
    (visite1 == 1 & visite2 == 2 & visite3 == 3)
  ) |>
  dplyr::mutate(interview_complete = 1) |>
  dplyr::select(interview__id, interview__key)

```

```{r}
#| label: charger les bases filtrées
 
# composer les spécifications pour les fichiers à charger
bases_specs <- c(
  # vecteur des fichiers
  params$fichier_menage,
  "interview__actions"
) |>
  # transformer en base
	tibble::enframe(name = NULL, value = "base") |>
  # ajouter / créer des colonnes pour la fonction
	dplyr::mutate(
    nom = dplyr::case_when(
      base == params$fichier_menage ~ "menages",
      .default = sub(x = base, pattern = "__", replacement = "_")
    ),
    dir = dirs$obtenir$menage$fusionnees,
    entretiens_acheves = list(entretiens_acheves)
  ) |>
  # organiser en ordre des arguments de la fonction
	dplyr::select(dir, base, nom, entretiens_acheves)

# créer une spécification pour la consommation alimentaire
conso_specs <- tibble::tibble(
  dir = dirs$obtenir$menage$derivees,
  base = "conso_alim_7j",
  nom = "conso_alim",
  entretiens_acheves = list(entretiens_acheves)
)

# adjoindre les spécs
bases_specs <- dplyr::bind_rows(bases_specs, conso_specs)

# capter les bases filtrées dans une liste de bases
dfs_filtrees <- bases_specs |>
	purrr::pmap(.f = filtrer_base) |>
	rlang::set_names(nm = bases_specs$nom)

```

```{r}
#| label: charger la composition des équipes

superviseur_enqueteur <- fs::path(dirs$obtenir$meta, "team_composition.dta") |>
  # ingérer la base
	haven::read_dta() |>
  # enlever d'éventuels utilisateur archivés
  dplyr::filter(IsArchived == 0) |>
  # retenir les colonnes superviseur et enquêteur, changeant les nom
  # dans pour être en phase avec ceux de la base de entretiens et l'enquêteur
  # responsable
	dplyr::select(
    supervisor = SupervisorName,
    interviewer = UserName
  )

```

```{r}
#| label: identifier l'enquêteur responsable pour chaque entretien

enquetes_enqueteur_responsable <- dfs_filtrees$interview_actions |>
	dplyr::group_by(interview__id, interview__key) |>
  # select the last completion event
  # complete
	dplyr::filter(action == 3) |>
	# last
	dplyr::filter(dplyr::row_number() == dplyr::n()) |>
  dplyr::ungroup() |>
	dplyr::mutate(
    # date d'achèvement
    date_entretien = lubridate::as_date(date),
    # semaine d'achèvement
    semaine_entretien = lubridate::floor_date(
      x = date_entretien, 
      unit = "week", 
      # week starts on Monday
      week_start = getOption("lubridate.week.start", 1)
    ),
    # dans la période du rapport
    periode_rapport = lubridate::`%within%`(
      date_entretien,
      lubridate::interval(
          start = params$rapport_debut, 
          end = params$rapport_fin
      )
    )
  ) |>
	dplyr::select(
    interview__id, interview__key,
    interviewer = originator,
    supervisor = responsible__name,
    date_entretien, semaine_entretien, periode_rapport
  )

```

```{r}
#| label: créer une base qui attribue chaque entretien à un enquêteur et supervisur
 
equipe_enqueteur_entretien <- superviseur_enqueteur |>
	dplyr::left_join(
    y = enquetes_enqueteur_responsable,
    by = c("supervisor", "interviewer")
  ) |>
	dplyr::select(
    supervisor, interviewer, interview__id, interview__key,
    date_entretien, semaine_entretien, periode_rapport
  )

```

```{r}
#| label: créer un sytle pour les tableaux reactable

# {reactable} table style
reactable_style <- reactable::reactableTheme(
  headerStyle = list(color = "#ffffff", background = "#0F2B1D"),
  groupHeaderStyle = list(color = "#ffffff", background = "#0F2B1D"),
  stripedColor = "#edfaea",
  searchInputStyle = list(
    backgroundColor = "#edfaea",
    borderColor = "#8cc0a5",
    borderWidth = "medium",
    "&:focus" = list(backgroundColor = "#edfaea", borderWidth = "thick", borderColor = "#0F2B1D"),
    "&:hover, &:focus" = list(borderWidth = "thick", borderColor = "#8cc0a5"),
    "&:hover::placeholder, &:focus::placeholder" = list(color = "#8cc0a5")            
  )
)

# reactable UI text
reactable_fr <- reactable::reactableLang(
  searchPlaceholder = "Rechercher",
  searchLabel = "Rechercher",
  noData = "Aucune ligne retrouvée",
  pageNext = "Suivant",
  pagePrevious = "Précédent",
  pageNumbers = "{page} de {pages}",
  pageInfo = "Lignes {rowStart} à {rowEnd} de {rows} lignes"
)

```

```{r}
#| label: définir une fonction pour les tableaux

#' Créer un tableau interactif
#'
#' @param df Data frame. Avec les colonnes :
#' - `supervisor`. Nom du chef d'équipe.
#' - `interviewer`. Nom du chef de l'enquêteur.
#' - `interview__id`. Character. Identifiant SuSo.
#' - `interview__key`. Character.Identifiant SuSo.
#' - `{{var}}`. Une colonne de l'indicateur.
#' - `semaine_entretien`. Date. Semaine de l'entretien.
#' - `period_rapport`. Boolean. Si l'entretien tombe dans la période du rapport.
#' @param var Bare variable name. Indicateur à traiter dans le tableau.
#' @param texte_ensemble Character. Texte à afficher dans le tableau pour le groupe de tous les entretiens pris ensemble.
#' @param theme reactable theme object.
#' @param language reactable language object.
#'
#' @return reactable table
#'
#' @importFrom dplyr filter group_by summarise n ungroup mutate arrange pull
#' select bind_rows left_join
#' @importFrom tidyr nest
#' @importFrom purrr map
#' @importFrom reactable reactable colDef colGroup
#' @importFrom dataui dui_sparkline dui_sparklineseries dui_tooltip
#' @importFrom htmlwidgets JS
creer_tableau_reactable <- function(
  df,
  var,
  texte_ensemble = "Ensemble",
  theme,
  language
) {


  # ----------------------------------------------------------------------------
  # calculer les statistiques
  # ----------------------------------------------------------------------------

  stats_par_equipe <- df |>
    dplyr::filter(periode_rapport == TRUE) |>
    dplyr::group_by(supervisor) |>
    dplyr::summarise(
      n = dplyr::n(),
      minimum = fivenum({{var}}, na.rm = TRUE)[1], 
      lower_hinge = fivenum({{var}}, na.rm = TRUE)[2], 
      median = fivenum({{var}}, na.rm = TRUE)[3], 
      upper_hinge = fivenum({{var}}, na.rm = TRUE)[4], 
      maximum = fivenum({{var}}, na.rm = TRUE)[5]
    ) |>
    dplyr::ungroup()

  stats_ensemble <- df |>
    dplyr::filter(periode_rapport == TRUE) |>
    dplyr::summarise(
      n = dplyr::n(),
      minimum = fivenum({{var}}, na.rm = TRUE)[1], 
      lower_hinge = fivenum({{var}}, na.rm = TRUE)[2], 
      median = fivenum({{var}}, na.rm = TRUE)[3], 
      upper_hinge = fivenum({{var}}, na.rm = TRUE)[4], 
      maximum = fivenum({{var}}, na.rm = TRUE)[5]
    ) |>
    dplyr::mutate(supervisor = texte_ensemble, .before = 1)


  tendance_par_equipe <- df |>
    # calculer la médiane par superviseur et par semaine
    dplyr::group_by(supervisor, semaine_entretien) |>
    dplyr::summarise({{var}} := median({{var}}, na.rm = TRUE)) |>
    dplyr::ungroup() |>
    # ordonner la base par superviseur et par semaine
    dplyr::arrange(supervisor, semaine_entretien) |>
    # créer une liste de mesures ordonnées par date pour chaque superviseur
    # d'abord, en ramenant les colonnes de la mesure et de la date en df imbrique
    # de sorte à préserver l'ordre
    # ensuite, en extrayant la mesure pour en faire une colonne liste
    dplyr::group_by(supervisor) |>
    tidyr::nest(tendances_df = c(semaine_entretien, {{var}})) |>
    dplyr::mutate(tendance = purrr::map(tendances_df, ~ dplyr::pull(.x, {{var}}))) |>
    dplyr::ungroup() |>
    dplyr::select(supervisor, tendance)

  tendance_ensemble <- df |>
    # calculer la médiane par semaine
    dplyr::group_by(semaine_entretien) |>
    dplyr::summarise({{var}} := median({{var}}, na.rm = TRUE)) |>
    dplyr::ungroup() |>
    # ordonner la base par superviseur et par semaine
    dplyr::arrange(semaine_entretien) |>
    # créer une liste de mesures ordonnées par date
    # d'abord, en ramenant les colonnes de la mesure et de la date en df imbrique
    # de sorte à préserver l'ordre
    # ensuite, en extrayant la mesure pour en faire une colonne liste
    tidyr::nest(tendances_df = c(semaine_entretien, {{var}})) |>
    dplyr::mutate(tendance = purrr::map(tendances_df, ~ dplyr::pull(.x, {{var}}))) |>
    dplyr::ungroup() |>
    dplyr::select(tendance) |>
    dplyr::mutate(supervisor = texte_ensemble, .before = 1)

  # ----------------------------------------------------------------------------
  # composer la base de statistiques
  # ----------------------------------------------------------------------------

  stats <- dplyr::bind_rows(
    stats_ensemble, stats_par_equipe
  )

  tendance <- dplyr::bind_rows(
    tendance_par_equipe, tendance_ensemble
  )

  stats_tbl <- stats |>
    dplyr::left_join(tendance, by = "supervisor")


  # ----------------------------------------------------------------------------
  # composer le tableau
  # ----------------------------------------------------------------------------

  reactable::reactable(
    data = stats_tbl,
    defaultColDef = reactable::colDef(
      width = 50
    ),
    columns = list(
      supervisor = reactable::colDef(
          name = "Équipe",
          width = 120
      ),
      n = reactable::colDef(
          name = "N. obs",
          width = 75
      ),
      minimum = reactable::colDef(name = "Min"),
      lower_hinge = reactable::colDef(name = "Q1"),
      median = reactable::colDef("Méd"),
      upper_hinge = reactable::colDef("Q3"),
      maximum = reactable::colDef("Max"),
      tendance = reactable::colDef(
        name = "Tendance",
        width = 350,
        cell = function(value, index) {
          dataui::dui_sparkline(
            data = value,
            components = list(
              dataui::dui_sparklineseries(
                # styling
                stroke = "#7E9384",
                showArea = TRUE,
                fill = "#7E9384"
              ),
              dataui::dui_tooltip(
                dataui::dui_sparkpointseries(
                  #styling
                  stroke = "#7E9384",
                  fill = "#fff",
                  #litle extra interactivity for demostration purposes
                  renderLabel = htmlwidgets::JS("(d) => d.toFixed(2)")
                )
              )
            )
          )
        }
      )
    ),
    columnGroups = list(
      reactable::colGroup(
        name = "Période du rapport",
        columns = c(
          "n", 
          "minimum", "lower_hinge", "median", "upper_hinge", "maximum"
        )
      ),
      reactable::colGroup(
        name = "Période de l'enquête",
        columns = "tendance"
      )
    ),
    striped = TRUE,
    sortable = TRUE,
    searchable = TRUE,
    fullWidth = FALSE,
    compact = TRUE,
    theme = theme,
    language = language  
  )

}

```

## Taille du ménage

```{r}
#| label: taille du ménage

# calculer les statistiques
taille_menage_par_entretien <- equipe_enqueteur_entretien |>
	dplyr::left_join(dfs_filtrees$menages, by = c("interview__id", "interview__key")) |>
	dplyr::mutate(
    dplyr::across(
      .cols = dplyr::matches("NOM_PRENOMS__[0-9]+$"),
      .fns = ~ !.x %in% c("##N/A##", "", NA_character_)
    ),
    n_membres = rowSums(
      dplyr::pick(dplyr::matches("NOM_PRENOMS__[0-9]$")),
      na.rm = TRUE
    )
  ) |>
	dplyr::select(
    supervisor, interviewer,
    interview__id, interview__key,
    n_membres,
    semaine_entretien, periode_rapport
  )

# créer le tableau
creer_tableau_reactable(
  df = taille_menage_par_entretien,
  var = n_membres,
  theme = reactable_style,
  language = reactable_fr
)

```

## Consommation alimentaire


```{r}
#| label: consommation alimentaire


# calculer l'indicateur
conso_alim_par_entretien <- equipe_enqueteur_entretien |>
	dplyr::left_join(dfs_filtrees$conso_alim, by = c("interview__id", "interview__key")) |>
  dplyr::mutate(n_prod_alim = !is.na(aliment__id)) |>
  dplyr::group_by(interview__id, interview__key) |>
	dplyr::summarise(
    n_prod_alim = sum(n_prod_alim, na.rm = TRUE),
    dplyr::across(
      .cols = c(supervisor, interviewer, semaine_entretien, periode_rapport),
      .fns = ~ dplyr::first(.x)
    )
  ) |>
	dplyr::ungroup() |>
	dplyr::select(
    supervisor, interviewer,
    interview__id, interview__key,
    n_prod_alim,
    semaine_entretien, periode_rapport
  )

# créer le tableau
creer_tableau_reactable(
  df = conso_alim_par_entretien,
  var = n_prod_alim,
  theme = reactable_style,
  language = reactable_fr
)

```
